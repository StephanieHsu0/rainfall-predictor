# -*- coding: utf-8 -*-
"""streamlit_app.py

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/14x4Z1lYmrBvE60oUr5AstrmL8GiqEw3c
"""

!pip install streamlit -q

import zipfile
import os
import shutil

# 建立資料夾
os.makedirs('/content/data/processed/', exist_ok=True)
os.makedirs('/content/models/', exist_ok=True)

# 解壓 processed_data.zip
with zipfile.ZipFile('/content/processed_data.zip', 'r') as zip_ref:
    zip_ref.extractall('/content/data/processed/')

# 解壓 models_lstm.zip 到臨時資料夾，再移動模型檔
with zipfile.ZipFile('/content/models_lstm.zip', 'r') as zip_ref:
    zip_ref.extractall('/content/temp_lstm/')
shutil.move('/content/temp_lstm/content/models/lstm_model.pth', '/content/models/lstm_model.pth')

# 解壓 models_timesnet.zip 到臨時資料夾，再移動模型檔
with zipfile.ZipFile('/content/models_timesnet.zip', 'r') as zip_ref:
    zip_ref.extractall('/content/temp_timesnet/')
shutil.move('/content/temp_timesnet/content/models/timesnet_model.pth', '/content/models/timesnet_model.pth')

print("✅ 所有檔案解壓與移動完成")

# Commented out IPython magic to ensure Python compatibility.
# %%writefile streamlit_app.py
# import streamlit as st
# import numpy as np
# import pandas as pd
# import torch
# import torch.nn as nn
# from sklearn.metrics import mean_absolute_error, mean_squared_error, r2_score
# import matplotlib.pyplot as plt
# 
# # 設定裝置
# device = torch.device("cuda" if torch.cuda.is_available() else "cpu")
# 
# # 模型定義
# class LSTMModel(nn.Module):
#     def __init__(self, input_dim, hidden_dim, output_dim, num_layers=2):
#         super(LSTMModel, self).__init__()
#         self.lstm = nn.LSTM(input_dim, hidden_dim, num_layers, batch_first=True)
#         self.fc = nn.Linear(hidden_dim, output_dim)
#     def forward(self, x):
#         out, _ = self.lstm(x)
#         return self.fc(out[:, -1, :])
# 
# class SimpleTimesNet(nn.Module):
#     def __init__(self, input_size, hidden_size, output_size):
#         super(SimpleTimesNet, self).__init__()
#         self.linear1 = nn.Linear(input_size, hidden_size)
#         self.relu = nn.ReLU()
#         self.linear2 = nn.Linear(hidden_size, output_size)
#     def forward(self, x):
#         x = x.view(x.size(0), -1)
#         return self.linear2(self.relu(self.linear1(x)))
# 
# # Streamlit 介面
# st.title("Hourly Rainfall Prediction Dashboard")
# st.sidebar.title("模型選擇與設定")
# 
# model_type = st.sidebar.selectbox("請選擇模型：", ["LSTM", "TimesNet"])
# show_samples = st.sidebar.slider("顯示前幾筆預測結果", 50, 500, 200, step=50)
# 
# # 載入資料
# try:
#     X = np.load("data/processed/X_test.npy")
#     Y = np.load("data/processed/Y_test.npy")
# except FileNotFoundError:
#     st.error("❌ 找不到測試資料，請確認路徑為 data/processed/")
#     st.stop()
# 
# X_tensor = torch.tensor(X, dtype=torch.float32).to(device)
# Y_tensor = torch.tensor(Y, dtype=torch.float32).to(device)
# 
# input_dim = X.shape[2]
# seq_len = X.shape[1]
# output_dim = Y.shape[1]
# 
# # 載入模型
# try:
#     if model_type == "LSTM":
#         model = LSTMModel(input_dim, 64, output_dim).to(device)
#         model.load_state_dict(torch.load("models/lstm_model.pth", map_location=device))
#     else:
#         model = SimpleTimesNet(seq_len * input_dim, 128, output_dim).to(device)
#         model.load_state_dict(torch.load("models/timesnet_model.pth", map_location=device))
# except FileNotFoundError:
#     st.error("❌ 找不到模型權重，請確認路徑為 models/lstm_model.pth 或 models/timesnet_model.pth")
#     st.stop()
# 
# # 預測
# model.eval()
# with torch.no_grad():
#     preds = model(X_tensor).cpu().numpy()
#     true = Y_tensor.cpu().numpy()
# 
# # 評估
# actual = true[:, 0]
# predicted = preds[:, 0]
# mask = ~np.isnan(actual) & ~np.isnan(predicted)
# actual = actual[mask]
# predicted = predicted[mask]
# 
# mae = mean_absolute_error(actual, predicted)
# rmse = np.sqrt(mean_squared_error(actual, predicted))
# r2 = r2_score(actual, predicted)
# 
# st.subheader("模型效能評估")
# st.write(f"**MAE**: {mae:.4f} mm")
# st.write(f"**RMSE**: {rmse:.4f} mm")
# st.write(f"**R² Score**: {r2:.4f}")
# 
# # 圖表
# st.subheader("預測圖 vs 實際降雨")
# fig, ax = plt.subplots(figsize=(10, 4))
# ax.plot(actual[:show_samples], label='Actual')
# ax.plot(predicted[:show_samples], label='Predicted', linestyle='--')
# ax.set_title(f"{model_type} Prediction (First {show_samples} Samples)")
# ax.set_xlabel("Time Step")
# ax.set_ylabel("Rainfall (mm)")
# ax.grid(True)
# ax.legend()
# st.pyplot(fig)
# 
# # 表格
# st.subheader("前幾筆預測結果")
# df_show = pd.DataFrame({
#     "Actual": actual[:show_samples],
#     "Predicted": predicted[:show_samples],
#     "Error": actual[:show_samples] - predicted[:show_samples]
# })
# st.dataframe(df_show.style.format("{:.3f}"))
#

!streamlit run streamlit_app.py & npx localtunnel --port 8501 --subdomain myrainfallapp

from google.colab import files
files.download("streamlit_app.py")

import zipfile
import os

# 建立資料夾路徑（若尚未建立）
os.makedirs('/content/data/processed', exist_ok=True)
os.makedirs('/content/models', exist_ok=True)

# 要壓縮的檔案清單（請確認這些檔案存在）
files_to_zip = [
    ('/content/data/processed/X_test.npy', 'data/processed/X_test.npy'),
    ('/content/data/processed/Y_test.npy', 'data/processed/Y_test.npy'),
    ('/content/models/lstm_model.pth', 'models/lstm_model.pth'),
    ('/content/models/timesnet_model.pth', 'models/timesnet_model.pth')
]

# 壓縮成 zip
zip_path = "/content/rainfall_model_data.zip"
with zipfile.ZipFile(zip_path, 'w') as zipf:
    for src, arcname in files_to_zip:
        if os.path.exists(src):
            zipf.write(src, arcname)
        else:
            print(f"⚠️ 找不到檔案：{src}")

print("✅ 壓縮完成，zip 檔案路徑：", zip_path)

from google.colab import files
files.download("/content/rainfall_model_data.zip")